<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>é›·éœ†æˆ˜æœºå°æ¸¸æˆ</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; margin: 0 auto; background: #222; }
        #score { color: #fff; text-align: center; font-size: 24px; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="score">åˆ†æ•°: 0</div>
    <div id="lifeBar" style="color:#fff;text-align:center;font-size:18px;margin-top:2px;"></div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <button id="restartBtn" style="display:none;position:fixed;left:50%;top:55%;transform:translate(-50%,-50%);z-index:20;font-size:22px;padding:12px 36px;border-radius:8px;background:#0ff;color:#222;border:none;box-shadow:0 0 16px #0ff;cursor:pointer;">é‡æ–°å¼€å§‹</button>
    <audio id="bgm" src="bgm.mp3" loop></audio>
    <audio id="hitSound" src="hit.mp3"></audio>
    <button id="muteBtn" style="position:fixed;right:24px;top:24px;z-index:30;font-size:16px;padding:6px 16px;border-radius:6px;background:#222;color:#fff;border:1px solid #0ff;">ğŸ”Š</button>
    <button id="taskBtn" style="position:fixed;right:24px;top:64px;z-index:30;font-size:16px;padding:6px 16px;border-radius:6px;background:#222;color:#fff;border:1px solid #0ff;">ä»»åŠ¡/æˆå°±</button>
    <div id="taskPanel" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:340px;max-width:90vw;background:rgba(0,0,0,0.95);color:#fff;z-index:100;padding:24px 18px 18px 18px;border-radius:12px;box-shadow:0 0 24px #0ff;">
        <h3 style="margin:0 0 12px 0;text-align:center;">ä»»åŠ¡ä¸æˆå°±</h3>
        <div id="taskList"></div>
        <div id="achieveList" style="margin-top:18px;"></div>
        <button id="closeTaskPanel" style="margin:18px auto 0 auto;display:block;padding:6px 32px;font-size:16px;border-radius:6px;background:#0ff;color:#222;border:none;">å…³é—­</button>
    </div>
    <div id="planeSelect" style="position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.85);z-index:10;display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <h2 style='color:#fff;'>é€‰æ‹©ä½ çš„æˆ˜æœº</h2>
        <div style="display:flex;gap:40px;">
            <div class="plane-option" data-type="balance" style="cursor:pointer;text-align:center;">
                <canvas id="planeBalance" width="60" height="90"></canvas><br>
                <span style='color:#0ff;'>å‡è¡¡å‹</span><br>
                <span style='color:#fff;font-size:12px;'>å‡è¡¡å±æ€§</span>
            </div>
            <div class="plane-option" data-type="speed" style="cursor:pointer;text-align:center;">
                <canvas id="planeSpeed" width="60" height="90"></canvas><br>
                <span style='color:#ff0;'>é€Ÿåº¦å‹</span><br>
                <span style='color:#fff;font-size:12px;'>ç§»åŠ¨å¿«ï¼Œç«åŠ›ä¸€èˆ¬</span>
            </div>
            <div class="plane-option" data-type="power" style="cursor:pointer;text-align:center;">
                <canvas id="planePower" width="60" height="90"></canvas><br>
                <span style='color:#f66;'>ç«åŠ›å‹</span><br>
                <span style='color:#fff;font-size:12px;'>ç«åŠ›å¼ºï¼Œç§»åŠ¨æ…¢</span>
            </div>
        </div>
    </div>
    <script>
        // å…¨å±€å˜é‡å£°æ˜ï¼ˆåªå£°æ˜ä¸€æ¬¡ï¼‰
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDiv = document.getElementById('score');
        const lifeBar = document.getElementById('lifeBar');
        const restartBtn = document.getElementById('restartBtn');
        const bgm = document.getElementById('bgm');
        const muteBtn = document.getElementById('muteBtn');
        const hitSound = document.getElementById('hitSound');

        // æ¸¸æˆçŠ¶æ€
        let gameStarted = false;
        let gameOver = false;
        let level = 1;
        let score = 0;
        let bullets = [];
        let enemies = [];
        let items = [];
        let leftPressed = false;
        let rightPressed = false;
        let spacePressed = false;
        let bulletCooldown = 0;
        let showLevelTip = false;
        let levelTipTimer = 0;
 let killCount = [0,0,0,0]; // [enemy1, enemy2, enemy3, enemy4]
        let equippedTitle = '';
        const levelUpScore = [0, 200, 500, 900, 1400, 2000, 2700, 3500, 4400, 5400];

        // ç©å®¶é£æœº
        const player = {
            x: canvas.width / 2 - 20,
            y: canvas.height - 60,
            width: 40,
            height: 60,
            speed: 5,
            savedSpeed: 5, // æ–°å¢ï¼Œè®°å½•åŸå§‹é€Ÿåº¦
            level: 1,
            type: 'balance',
            bulletColor: '#fff',
            lives: 3,
            hp: 100,
            maxHp: 100,
            shield: 0,
            powerUp: 0,
            speedUp: 0 // æ–°å¢ï¼ŒåŠ é€Ÿå‰©ä½™å¸§æ•°
        };

        // æ˜Ÿæ˜ŸèƒŒæ™¯æ•°æ®
        const STAR_NUM = 80;
        let stars = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < STAR_NUM; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: Math.random() * 1.5 + 0.5,
                    speed: Math.random() * 0.5 + 0.2,
                    alpha: Math.random() * 0.5 + 0.5,
                    twinkle: Math.random() * 0.05 + 0.01
                });
            }
        }
        initStars();
        function drawStars() {
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(star => {
                ctx.save();
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.r, 0, 2 * Math.PI);
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
                // æ˜Ÿæ˜Ÿç§»åŠ¨å’Œé—ªçƒ
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                star.alpha += (Math.random() - 0.5) * star.twinkle;
                if (star.alpha > 1) star.alpha = 1;
                if (star.alpha < 0.2) star.alpha = 0.2;
            });
            ctx.restore();
        }

        // é€‰æ‹©é£æœºé€»è¾‘
        function showLevel(levelNum) {
            showLevelTip = true;
            levelTipTimer = 60; // æ˜¾ç¤º60å¸§
        }
        // æ•Œäººè´´å›¾åŠ è½½ï¼ˆ4ä¸ªè‡ªå®šä¹‰ï¼‰
        const enemyImages = [
            (() => { let img = new Image(); img.src = 'enemy1.png'; return img; })(),
            (() => { let img = new Image(); img.src = 'enemy2.png'; return img; })(),
            (() => { let img = new Image(); img.src = 'enemy3.png'; return img; })(),
            (() => { let img = new Image(); img.src = 'enemy4.png'; return img; })()
        ];
        // é€‰é£æœºäº‹ä»¶ï¼Œå½»åº•é‡ç½®æ‰€æœ‰çŠ¶æ€
        document.querySelectorAll('.plane-option').forEach(opt => {
            opt.onclick = function() {
                const t = this.getAttribute('data-type');
                player.type = t;
                player.speed = planeTypes[t].speed;
                player.savedSpeed = player.speed; // åŒæ­¥åŸå§‹é€Ÿåº¦
                player.bulletColor = planeTypes[t].bulletColor;
                player.lives = 3;
                player.hp = player.maxHp = 100;
                player.x = canvas.width / 2 - 20;
                player.y = canvas.height - 60;
                player.level = 1;
                bullets = [];
                enemies = [];
                items = [];
                score = 0;
                level = 1;
                showLevelTip = false;
                levelTipTimer = 0;
                gameStarted = true;
                gameOver = false;
                player.speedUp = 0; // é‡ç½®åŠ é€Ÿ
                document.getElementById('planeSelect').style.display = 'none';
                if (bgm.paused) {
                    bgm.currentTime = 0;
                    bgm.play().catch(()=>{});
                }
                showLevel(level);
                killCount = [0,0,0,0]; // é‡ç½®å‡»æ€ç»Ÿè®¡
            }
        });

        // é‡æ–°å¼€å§‹æŒ‰é’®
        restartBtn.onclick = function() {
            // åªé‡ç½®çŠ¶æ€ï¼Œæ˜¾ç¤ºé£æœºé€‰æ‹©ç•Œé¢
            gameStarted = false;
            gameOver = false;
            restartBtn.style.display = 'none';
            document.getElementById('planeSelect').style.display = 'flex';
            initStars();
            player.speedUp = 0; // é‡ç½®åŠ é€Ÿ
            killCount = [0,0,0,0]; // é‡ç½®å‡»æ€ç»Ÿè®¡
        }

// ç›‘å¬é”®ç›˜
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') leftPressed = true;
            if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') rightPressed = true;
            if (e.code === 'Space') spacePressed = true;
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') leftPressed = false;
            if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') rightPressed = false;
            if (e.code === 'Space') spacePressed = false;
        });

        // å‘å°„å­å¼¹å†·å´

        // å‡çº§ä¸ºäº”çº§ï¼Œåˆ†æ•°åˆ¤å®š
        function getLevelByScore(score) {
            if (score >= 1000) return 5;
            if (score >= 600) return 4;
            if (score >= 300) return 3;
            if (score >= 100) return 2;
            return 1;
        }

        function drawPlayer() {
            const t = player.type;
            if (t && planeTypes[t]) {
                planeTypes[t].draw(ctx, player.x, player.y, player.width, player.height, player.level);
            } else {
                ctx.save();
                ctx.fillStyle = '#0ff';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.restore();
            }
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save();
                ctx.fillStyle = bullet.color || player.bulletColor || '#ff0';
                if (bullet.glow) {
                    ctx.shadowColor = bullet.color || '#0ff';
                    ctx.shadowBlur = 18;
                } else {
                    ctx.shadowColor = player.bulletColor || '#ff0';
                    ctx.shadowBlur = 10;
                }
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                ctx.restore();
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                if (enemy.isBoss) {
                    // Bosså‘å…‰æè¾¹
                    ctx.save();
                    ctx.shadowColor = '#ff0';
                    ctx.shadowBlur = 32;
                    if (enemy.img && enemy.img.complete && enemy.img.naturalWidth > 0) {
                        ctx.drawImage(enemy.img, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else {
                        ctx.fillStyle = '#f00';
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                    ctx.restore();
                    // Bossæè¾¹
                    ctx.save();
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 6;
                    ctx.globalAlpha = 0.7;
                    ctx.strokeRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.restore();
                } else {
                    if (enemy.img && enemy.img.complete && enemy.img.naturalWidth > 0) {
                        ctx.drawImage(enemy.img, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else {
                        ctx.fillStyle = '#f00';
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                }
            });
        }

        // é“å…·ç±»å‹ä¸å›¾ç‰‡ï¼ˆè¯·å°†gifåŠ¨å›¾æ”¾åœ¨imgç›®å½•ä¸‹ï¼‰
        const itemTypes = [
            {type: 'heal', img: 'img/heart.gif'},      // åŠ è¡€
            {type: 'power', img: 'img/powerup.gif'},   // ç«åŠ›æå‡
            {type: 'shield', img: 'img/shield.gif'},   // æŠ¤ç›¾
            {type: 'speed', img: 'img/speedup.png'}    // åŠ é€Ÿï¼ˆpngï¼‰
        ];
        // é¢„åŠ è½½é“å…·å›¾ç‰‡
        const itemImages = {
            heal: new Image(),
            power: new Image(),
            shield: new Image(),
            speed: new Image()
        };
        itemImages.heal.src = 'img/heart.gif';
        itemImages.power.src = 'img/powerup.gif';
        itemImages.shield.src = 'img/shield.gif';
        itemImages.speed.src = 'img/speedup.png';

        // Bosså‡»æ€ç‰¹æ•ˆæ•°æ®
        let bossExplosions = [];
        // åªå…è®¸Bossæ‰è½é“å…·
        function enemyDropItem(enemy) {
            if (enemy.isBoss && Math.random() < 0.8) { // Bossé«˜æ¦‚ç‡æ‰è½
                const item = itemTypes[Math.floor(Math.random()*itemTypes.length)];
                items.push({
                    x: enemy.x + enemy.width/2 - 16,
                    y: enemy.y + enemy.height/2 - 16,
                    width: 32,
                    height: 32,
                    type: item.type,
                    img: item.img,
                    speed: 2
                });
            }
        }
        // Bosså‡»æ€ç‰¹æ•ˆç”Ÿæˆ
        function spawnBossExplosion(x, y) {
            bossExplosions.push({
                x, y, frame: 0, maxFrame: 40,
                particles: [
                    // æŸ”å’Œè“è‰²ç²’å­
                    ...Array.from({length: 28}, () => ({
                        type: 'normal',
                        angle: Math.random()*2*Math.PI,
                        radius: 0,
                        speed: 3+Math.random()*5,
                        color: 'rgba(120,180,255,0.85)',
                        size: 12+Math.random()*6
                    })),
                    // æŸ”å’Œç´«è‰²ç²’å­
                    ...Array.from({length: 10}, () => ({
                        type: 'normal',
                        angle: Math.random()*2*Math.PI,
                        radius: 0,
                        speed: 2+Math.random()*4,
                        color: 'rgba(180,140,255,0.8)',
                        size: 10+Math.random()*5
                    })),
                    // ç™½è‰²æ˜Ÿæ˜Ÿç²’å­
                    ...Array.from({length: 8}, () => ({
                        type: 'star',
                        angle: Math.random()*2*Math.PI,
                        radius: 0,
                        speed: 2+Math.random()*3,
                        color: 'rgba(255,255,255,0.9)',
                        size: 14+Math.random()*6
                    })),
                    // æ·¡è“è‰²é—ªç”µç²’å­
                    ...Array.from({length: 4}, () => ({
                        type: 'lightning',
                        angle: Math.random()*2*Math.PI,
                        radius: 0,
                        speed: 3+Math.random()*3,
                        color: 'rgba(120,220,255,0.7)',
                        size: 18
                    }))
                ],
                rings: [
                    {r: 0, maxR: 60, alpha: 0.5, color: 'rgba(120,180,255,0.35)'},
                    {r: 0, maxR: 36, alpha: 0.3, color: 'rgba(180,140,255,0.22)'}
                ],
                flash: true // çˆ†ç‚¸ç¬é—´é—ªå…‰
            });
        }
        // ç»˜åˆ¶Bosså‡»æ€ç‰¹æ•ˆ
        function drawBossExplosions() {
            bossExplosions.forEach(expl => {
                // æŸ”å’Œèƒ½é‡æ³¢çº¹
                expl.rings.forEach(ring => {
                    ctx.save();
                    ctx.globalAlpha = ring.alpha * (1 - ring.r / ring.maxR);
                    ctx.strokeStyle = ring.color;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(expl.x, expl.y, ring.r, 0, 2*Math.PI);
                    ctx.stroke();
                    ctx.restore();
                    // çˆ†ç‚¸å…‰åœˆèŒƒå›´å†…çš„æ•Œäººè¢«ç‚¸æ­»
                    if (ring.r > 30 && ring.r <= ring.maxR) {
                        for (let i = enemies.length - 1; i >= 0; i--) {
                            const enemy = enemies[i];
                            const ex = enemy.x + enemy.width/2;
                            const ey = enemy.y + enemy.height/2;
                            const dist = Math.sqrt((ex - expl.x) * (ex - expl.x) + (ey - expl.y) * (ey - expl.y));
                            if (dist < ring.r + enemy.width/2) {
                                if(enemy.isBoss) {
                                    spawnBossExplosion(ex, ey);
                                } else {
                                    spawnEnemyExplosion(ex, ey);
                                }
                                enemyDropItem(enemy);
                                enemies.splice(i, 1);
                                score += 10;
                                if (hitSound) { hitSound.currentTime = 0; hitSound.play().catch(()=>{}); }
                            }
                        }
                    }
                });
                // ç²’å­
                expl.particles.forEach(p => {
                    const px = expl.x + Math.cos(p.angle)*p.radius;
                    const py = expl.y + Math.sin(p.angle)*p.radius;
                    ctx.save();
                    ctx.globalAlpha = 1 - expl.frame/expl.maxFrame;
                    if (p.type === 'normal') {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 16;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(px, py, p.size, 0, 2*Math.PI);
                        ctx.fill();
                    } else if (p.type === 'star') {
                        ctx.fillStyle = p.color;
                        drawStar(ctx, px, py, p.size, 5, 0.5);
                    } else if (p.type === 'lightning') {
                        ctx.strokeStyle = p.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        for(let i=0;i<5;i++){
                            let dx = px + (Math.random()-0.5)*p.size;
                            let dy = py + (Math.random()-0.5)*p.size;
                            ctx.lineTo(dx, dy);
                        }
                        ctx.stroke();
                    }
                    ctx.restore();
                });
                // çˆ†ç‚¸é—ªå…‰
                if (expl.flash && expl.frame < 6) {
                    ctx.save();
                    ctx.globalAlpha = 0.10 * (6 - expl.frame);
                    ctx.fillStyle = '#eaf6ff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }
            });
        }
        // ç”»äº”è§’æ˜Ÿ
        function drawStar(ctx, x, y, r, points, inset) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x, y - r);
            for (let i = 0; i < points * 2; i++) {
                let angle = Math.PI / points * i;
                let len = i % 2 === 0 ? r : r * inset;
                ctx.lineTo(x + Math.sin(angle) * len, y - Math.cos(angle) * len);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        // æ›´æ–°Bosså‡»æ€ç‰¹æ•ˆ
        function updateBossExplosions() {
            bossExplosions.forEach(expl => {
                expl.frame++;
                expl.particles.forEach(p => {
                    p.radius += p.speed;
                    if (p.type === 'normal' || p.type === 'star') {
                        p.size *= 0.97;
                    }
                });
                expl.rings.forEach(ring => {
                    ring.r += 6;
                });
                if (expl.frame > 6) expl.flash = false;
            });
            bossExplosions = bossExplosions.filter(expl => expl.frame < expl.maxFrame);
        }

        // æ™®é€šæ•Œäººå‡»æ€ç‰¹æ•ˆï¼ˆè‡ªå®šä¹‰å…¥å£ï¼‰
        let enemyExplosions = [];
        function spawnEnemyExplosion(x, y) {
            enemyExplosions.push({
                x, y, frame: 0, maxFrame: 18, particles: Array.from({length: 12}, () => ({
                    angle: Math.random() * 2 * Math.PI,
                    radius: 0,
                    speed: 1 + Math.random() * 2,
                    color: 'orange' // ä½ å¯ä»¥è‡ªå®šä¹‰é¢œè‰²/æ¸å˜/å›¾ç‰‡
                }))
            });
        }
        function updateEnemyExplosions() {
            enemyExplosions.forEach(expl => {
                expl.frame++;
                expl.particles.forEach(p => { p.radius += p.speed; });
            });
            enemyExplosions = enemyExplosions.filter(expl => expl.frame < expl.maxFrame);
        }
        function drawEnemyExplosions() {
            enemyExplosions.forEach(expl => {
                expl.particles.forEach(p => {
                    const px = expl.x + Math.cos(p.angle) * p.radius;
                    const py = expl.y + Math.sin(p.angle) * p.radius;
                    ctx.save();
                    ctx.globalAlpha = 1 - expl.frame / expl.maxFrame;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                });
            });
        }

        function updateItems() {
            items.forEach(item => item.y += item.speed);
            items = items.filter(item => item.y < canvas.height);
        }
        // ç»˜åˆ¶é“å…·ç”¨gifå›¾ç‰‡ï¼Œå¸¦å®¹é”™å¤„ç†
        function drawItems() {
            items.forEach(item => {
                let image = itemImages[item.type];
                if (image && image.complete && image.naturalWidth > 0) {
                    ctx.drawImage(image, item.x, item.y, item.width, item.height);
                }
            });
        }

        function update() {
            if (!gameStarted || gameOver) return;
            // å‡çº§åˆ¤å®šï¼ˆäº”çº§ï¼‰
            player.level = getLevelByScore(score);
            // å…³å¡åˆ¤å®š
            if (level < levelUpScore.length && score >= levelUpScore[level]) {
                level++;
                showLevel(level);
                if (bgm.paused) {
                    bgm.currentTime = 0;
                    bgm.play().catch(()=>{});
                }
            }
            // ç©å®¶ç§»åŠ¨
            if (leftPressed && player.x > 0) player.x -= player.speed;
            if (rightPressed && player.x < canvas.width - player.width) player.x += player.speed;
            // å‘å°„å­å¼¹
            if (spacePressed && bulletCooldown <= 0) {
                if (player.level === 1) {
                    // å•å‘
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 4,
                        height: 10,
                        speed: 8
                    });
                } else if (player.level === 2) {
                    // åŒå‘
                    bullets.push({
                        x: player.x + player.width / 2 - 12,
                        y: player.y + 10,
                        width: 4,
                        height: 10,
                        speed: 8
                    });
                    bullets.push({
                        x: player.x + player.width / 2 + 8,
                        y: player.y + 10,
                        width: 4,
                        height: 10,
                        speed: 8
                    });
                } else if (player.level === 3) {
                    // ä¸‰å‘
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 4,
                        height: 14,
                        speed: 10
                    });
                    bullets.push({
                        x: player.x + player.width / 2 - 16,
                        y: player.y + 12,
                        width: 4,
                        height: 10,
                        speed: 8
                    });
                    bullets.push({
                        x: player.x + player.width / 2 + 12,
                        y: player.y + 12,
                        width: 4,
                        height: 10,
                        speed: 8
                    });
                } else if (player.level === 4) {
                    // å››å‘+ä¸­é—´æ¿€å…‰
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 4,
                        height: 18,
                        speed: 12,
                        color: '#0ff',
                        glow: true
                    });
                    bullets.push({
                        x: player.x + player.width / 2 - 18,
                        y: player.y + 12,
                        width: 4,
                        height: 12,
                        speed: 9,
                        color: '#fff',
                        glow: true
                    });
                    bullets.push({
                        x: player.x + player.width / 2 + 14,
                        y: player.y + 12,
                        width: 4,
                        height: 12,
                        speed: 9,
                        color: '#fff',
                        glow: true
                    });
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y + 8,
                        width: 2,
                        height: 24,
                        speed: 14,
                        color: '#0ff',
                        glow: true
                    });
                } else if (player.level === 5) {
                    // äº”å‘+åŒæ¿€å…‰+å¤§èƒ½é‡å¼¹
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 6,
                        height: 22,
                        speed: 15,
                        color: '#fff',
                        glow: true
                    });
                    bullets.push({
                        x: player.x + player.width / 2 - 22,
                        y: player.y + 14,
                        width: 4,
                        height: 14,
                        speed: 10,
                        color: '#0ff',
                        glow: true
                    });
                    bullets.push({
                        x: player.x + player.width / 2 + 18,
                        y: player.y + 14,
                        width: 4,
                        height: 14,
                        speed: 10,
                        color: '#0ff',
                        glow: true
                    });
                    // åŒæ¿€å…‰
                    bullets.push({
                        x: player.x + player.width / 2 - 10,
                        y: player.y,
                        width: 2,
                        height: 32,
                        speed: 16,
                        color: '#0ff',
                        glow: true
                    });
                    bullets.push({
                        x: player.x + player.width / 2 + 8,
                        y: player.y,
                        width: 2,
                        height: 32,
                        speed: 16,
                        color: '#0ff',
                        glow: true
                    });
                }
                bulletCooldown = 10;
            }
            if (bulletCooldown > 0) bulletCooldown--;

            // æ›´æ–°å­å¼¹
            bullets.forEach(bullet => bullet.y -= bullet.speed);
            bullets = bullets.filter(bullet => bullet.y + bullet.height > 0);

            // ç”Ÿæˆæ•Œæœºï¼Œéšå…³å¡æå‡æ¦‚ç‡å’Œé€Ÿåº¦æå‡
            let enemyRate = 0.02 + level * 0.008;
            if (Math.random() < enemyRate) {
                // éšæœºé€‰æ‹©ä¸€å¼ æ•Œäººå›¾ç‰‡
                const imgIdx = Math.floor(Math.random() * enemyImages.length);
                enemies.push({
                    x: Math.random() * (canvas.width - 40),
                    y: -40,
                    width: 40,
                    height: 40,
                    speed: 2 + Math.random() * (1.2 + level * 0.3),
                    img: enemyImages[imgIdx],
                    isBoss: false
                });
            }
            // å¶å°”ç”ŸæˆBossæ•Œäººï¼ˆ0.2%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.002) {
                const imgIdx = Math.floor(Math.random() * enemyImages.length);
                const bossW = 100, bossH = 100;
                enemies.push({
                    x: Math.random() * (canvas.width - bossW),
                    y: -bossH,
                    width: bossW,
                    height: bossH,
                    speed: 2 + Math.random() * (1.2 + level * 0.2),
                    img: enemyImages[imgIdx],
                    isBoss: true
                });
            }
            // æ›´æ–°æ•Œæœº
            enemies.forEach(enemy => enemy.y += enemy.speed);
            enemies = enemies.filter(enemy => enemy.y < canvas.height);
            // æ›´æ–°é“å…·
            updateItems();
            updateBossExplosions();
            updateEnemyExplosions(); // æ›´æ–°æ™®é€šæ•Œäººç‰¹æ•ˆ
            // ç©å®¶åƒåˆ°é“å…·
            items.forEach((item, idx) => {
                if (
                    player.x < item.x + item.width &&
                    player.x + player.width > item.x &&
                    player.y < item.y + item.height &&
                    player.y + player.height > item.y
                ) {
                    if(item.type==='heal') {
                        player.hp = Math.min(player.maxHp, player.hp+40);
                    } else if(item.type==='power') {
                        player.powerUp = 600; // 10ç§’ç«åŠ›æå‡
                    } else if(item.type==='shield') {
                        player.shield = 600; // 10ç§’æ— æ•Œ
                    } else if(item.type==='speed') {
                        if (player.speedUp <= 0) {
                            player.savedSpeed = player.speed;
                            player.speed += 2;
                        }
                        player.speedUp = 600; // 10ç§’
                    }
                    items.splice(idx, 1);
                }
            });
            // é“å…·æ•ˆæœå€’è®¡æ—¶
            if(player.powerUp>0) player.powerUp--;
            if(player.shield>0) player.shield--;
            if(player.speedUp>0) {
                player.speedUp--;
                if(player.speedUp===0) {
                    player.speed = player.savedSpeed;
                }
            }
            // ç¢°æ’æ£€æµ‹
            bullets.forEach((bullet, bIdx) => {
                enemies.forEach((enemy, eIdx) => {
                    if (
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y
                    ) {
                        bullets.splice(bIdx, 1);
                        if(enemy.isBoss) {
                            spawnBossExplosion(enemy.x+enemy.width/2, enemy.y+enemy.height/2);
                        } else {
                            spawnEnemyExplosion(enemy.x+enemy.width/2, enemy.y+enemy.height/2);
                        }
                        // æ–°å¢ï¼šç»Ÿè®¡å‡»æ€ç±»å‹
                        let typeIdx = 0;
                        if(enemy.img && enemy.img.src){
                            if(enemy.img.src.indexOf('enemy1')!==-1) typeIdx=0;
                            else if(enemy.img.src.indexOf('enemy2')!==-1) typeIdx=1;
                            else if(enemy.img.src.indexOf('enemy3')!==-1) typeIdx=2;
                            else if(enemy.img.src.indexOf('enemy4')!==-1) typeIdx=3;
                        }
                        killCount[typeIdx]++;
                        enemyDropItem(enemy);
                        enemies.splice(eIdx, 1);
                        score += 10;
                        if (hitSound) { hitSound.currentTime = 0; hitSound.play().catch(()=>{}); }
                    }
                });
            });
            // ç©å®¶ä¸æ•Œæœºç¢°æ’
            enemies.forEach((enemy, eIdx) => {
                if (
                    player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y
                ) {
                    if(player.shield>0) {
                        // æœ‰æŠ¤ç›¾æ— æ•Œ
                        enemies.splice(eIdx,1);
                    } else {
                        player.hp -= 50;
                        enemies.splice(eIdx,1);
                        if(player.hp<=0) {
                            player.lives--;
                            if(player.lives>0) {
                                player.hp = player.maxHp;
                                player.x = canvas.width / 2 - 20;
                                player.y = canvas.height - 60;
                            } else {
                                gameOver = true;
                                // æ–°å¢ï¼šåˆ¤å®šç‰¹æ®Šæˆå°±
                                checkSpecialAchievements();
                            }
                        }
                    }
                }
            });
        }

        function draw() {
            drawStars();
            drawPlayer();
            drawBullets();
            drawEnemies();
            drawItems();
            drawBossExplosions(); // Bossç‰¹æ•ˆ
            drawEnemyExplosions(); // æ™®é€šæ•Œäººç‰¹æ•ˆ
            // å…³å¡æç¤º
            if (showLevelTip && levelTipTimer > 0) {
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ç¬¬ ' + level + ' å…³', canvas.width / 2, canvas.height / 2 - 60);
                ctx.restore();
                levelTipTimer--;
                if (levelTipTimer === 0) showLevelTip = false;
            }
            if (gameOver) {
                ctx.fillStyle = '#fff';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ¸¸æˆç»“æŸ', canvas.width / 2, canvas.height / 2);
                restartBtn.style.display = 'block';
            } else {
                restartBtn.style.display = 'none';
            }
        }

        // ç”Ÿå‘½æ˜¾ç¤º
        function updateLifeBar() {
            let hearts = '';
            for(let i=0;i<player.lives;i++) hearts+='â¤';
            lifeBar.innerHTML = `ç”Ÿå‘½ï¼š${hearts} HP:${player.hp}`
                + (player.shield>0?' <span style="color:#0ff">[æŠ¤ç›¾]</span>':'')
                + (player.powerUp>0?' <span style="color:#f0f">[ç«åŠ›UP]</span>':'')
                + (player.speedUp>0?' <span style="color:#0cf">[åŠ é€Ÿ]</span>':'')
                + (equippedTitle?` <span style='color:#ffd700;font-weight:bold;'>[${equippedTitle}]</span>`:'');
        }

        // é£æœºç±»å‹æ•°æ®ï¼ˆäº”çº§ç‰¹æ•ˆï¼‰
        const planeTypes = {
            balance: {
                name: 'å‡è¡¡å‹', color: '#0ff', speed: 5, bulletColor: '#fff',
                draw: function(ctx, x, y, w, h, level) {
                    let t = Date.now()/300;
                    if (level === 1) {
                        // æ¸å˜è“è‰²æœºèº«+ç™½è‰²ä¸­çº¿
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#0ff'); grad.addColorStop(1, '#08f');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y);
                        ctx.lineTo(x, y + h);
                        ctx.lineTo(x + w, y + h);
                        ctx.closePath(); ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(x + w/2, y); ctx.lineTo(x + w/2, y + h); ctx.stroke();
                    } else if (level === 2) {
                        // æœºèº«+èƒ½é‡ç¯+å°å…‰ç¿¼
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#0ff'); grad.addColorStop(1, '#a0f');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y);
                        ctx.lineTo(x - 10, y + h);
                        ctx.lineTo(x + w + 10, y + h);
                        ctx.closePath(); ctx.fill();
                        // èƒ½é‡ç¯
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*0.6, 0, 2*Math.PI);
                        ctx.stroke();
                        ctx.restore();
                        // å°å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.5);
                        ctx.lineTo(x - 24, y + h);
                        ctx.moveTo(x + w/2, y + h*0.5);
                        ctx.lineTo(x + w + 24, y + h);
                        ctx.stroke();
                        ctx.restore();
                    } else if (level === 3) {
                        // æœºèº«+ç²’å­ç¯+èƒ½é‡çˆ†å‘+å…‰ç¿¼
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#0ff');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 10);
                        ctx.lineTo(x - 15, y + h);
                        ctx.lineTo(x + w + 15, y + h);
                        ctx.closePath(); ctx.fill();
                        // ç²’å­ç¯
                        for(let i=0;i<10;i++){
                            let angle = Math.PI*2*i/10 + t;
                            let px = x + w/2 + Math.cos(angle)*w*0.8;
                            let py = y + h*0.6 + Math.sin(angle)*w*0.8;
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(px, py, 4+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        // èƒ½é‡çˆ†å‘
                        ctx.save();
                        ctx.globalAlpha = 0.3+0.2*Math.abs(Math.sin(t));
                        ctx.fillStyle = '#0ff';
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*0.7 + 10*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                        ctx.fill();
                        ctx.restore();
                        // å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 12;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.4);
                        ctx.lineTo(x - 32, y + h);
                        ctx.moveTo(x + w/2, y + h*0.4);
                        ctx.lineTo(x + w + 32, y + h);
                        ctx.stroke();
                        ctx.restore();
                    } else if (level === 4) {
                        // æœºèº«+å¤§å…‰ç¿¼+çˆ†ç‚¸ç¯+é—ªç”µ
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#0ff');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 16);
                        ctx.lineTo(x - 22, y + h);
                        ctx.lineTo(x + w + 22, y + h);
                        ctx.closePath(); ctx.fill();
                        // å¤§å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.5+0.2*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#0ff';
                        ctx.lineWidth = 24;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.3);
                        ctx.lineTo(x - 60, y + h + 20*Math.sin(t));
                        ctx.moveTo(x + w/2, y + h*0.3);
                        ctx.lineTo(x + w + 60, y + h + 20*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                        // çˆ†ç‚¸ç¯
                        ctx.save();
                        ctx.globalAlpha = 0.3+0.2*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*0.9 + 12*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                        ctx.stroke();
                        ctx.restore();
                        // é—ªç”µ
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        for(let i=0;i<2;i++){
                            let baseX = i===0 ? x-10 : x+w+10;
                            ctx.beginPath();
                            ctx.moveTo(x + w/2, y + h*0.5);
                            for(let j=0;j<5;j++){
                                let dx = baseX + (Math.random()-0.5)*10;
                                let dy = y + h*0.5 + (j+1)*(h*0.1);
                                ctx.lineTo(dx, dy);
                            }
                            ctx.stroke();
                        }
                        ctx.restore();
                    } else if (level === 5) {
                        // æœºèº«+è¶…å¤§å…‰ç¿¼+å¤šé‡èƒ½é‡ç¯+ç²’å­çˆ†å‘+å…‰æŸ
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#0ff');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 24);
                        ctx.lineTo(x - 36, y + h);
                        ctx.lineTo(x + w + 36, y + h);
                        ctx.closePath(); ctx.fill();
                        // è¶…å¤§å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.4+0.3*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#0ff';
                        ctx.lineWidth = 40;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.2);
                        ctx.lineTo(x - 120, y + h + 60*Math.sin(t));
                        ctx.moveTo(x + w/2, y + h*0.2);
                        ctx.lineTo(x + w + 120, y + h + 60*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                        // å¤šé‡èƒ½é‡ç¯
                        for(let k=0;k<3;k++){
                            ctx.save();
                            ctx.globalAlpha = 0.2+0.2*k;
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 10-2*k;
                            ctx.beginPath();
                            ctx.arc(x + w/2, y + h*0.7, w*1.1 + 18*k*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                            ctx.stroke();
                            ctx.restore();
                        }
                        // ç²’å­çˆ†å‘
                        for(let i=0;i<18;i++){
                            let angle = Math.PI*2*i/18 + t;
                            let px = x + w/2 + Math.cos(angle)*(w*1.2+20*Math.abs(Math.sin(t)));
                            let py = y + h*0.7 + Math.sin(angle)*(w*1.2+20*Math.abs(Math.sin(t)));
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(px, py, 6+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        // å…‰æŸ
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#0ff';
                        ctx.lineWidth = 12;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h);
                        ctx.lineTo(x + w/2, y + h + 80 + 40*Math.abs(Math.sin(t)));
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            },
            speed: {
                name: 'é€Ÿåº¦å‹', color: '#ff0', speed: 8, bulletColor: '#0f0',
                draw: function(ctx, x, y, w, h, level) {
                    let t = Date.now()/200;
                    if (level === 1) {
                        // é»„è‰²æœºèº«+ç»¿è‰²å°¾ç„°
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#ff0'); grad.addColorStop(1, '#fa0');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y-8);
                        ctx.lineTo(x-8, y + h);
                        ctx.lineTo(x + w+8, y + h);
                        ctx.closePath(); ctx.fill();
                        // å°¾ç„°
                        ctx.fillStyle = '#0f0';
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h);
                        ctx.lineTo(x + w/2 - 8, y + h + 18);
                        ctx.lineTo(x + w/2 + 8, y + h + 18);
                        ctx.closePath(); ctx.fill();
                    } else if (level === 2) {
                        // æœºèº«+æµçº¿å…‰å¸¦+åŒå°¾ç„°
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#ff0'); grad.addColorStop(1, '#0f0');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y-10);
                        ctx.lineTo(x-12, y + h);
                        ctx.lineTo(x + w+12, y + h);
                        ctx.closePath(); ctx.fill();
                        // æµçº¿å…‰å¸¦
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#0f0';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y);
                        ctx.bezierCurveTo(x + w/2 - 20, y + h*0.5, x + w/2 + 20, y + h*0.7, x + w/2, y + h);
                        ctx.stroke();
                        ctx.restore();
                        // åŒå°¾ç„°
                        ctx.fillStyle = '#0f0';
                        ctx.beginPath();
                        ctx.moveTo(x + 10, y + h);
                        ctx.lineTo(x, y + h + 18);
                        ctx.lineTo(x + 20, y + h + 10);
                        ctx.closePath(); ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(x + w - 10, y + h);
                        ctx.lineTo(x + w, y + h + 18);
                        ctx.lineTo(x + w - 20, y + h + 10);
                        ctx.closePath(); ctx.fill();
                    } else if (level === 3) {
                        // æœºèº«+æµæ˜Ÿå°¾+æ—‹è½¬æ¨è¿›å™¨
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#0f0');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y-16);
                        ctx.lineTo(x-16, y + h);
                        ctx.lineTo(x + w+16, y + h);
                        ctx.closePath(); ctx.fill();
                        // æ—‹è½¬æ¨è¿›å™¨
                        for(let i=0;i<4;i++){
                            let angle = t + Math.PI/2*i;
                            let px = x + w/2 + Math.cos(angle)*w*0.5;
                            let py = y + h + Math.sin(angle)*w*0.5;
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#0f0';
                            ctx.beginPath();
                            ctx.arc(px, py, 6+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        // æµæ˜Ÿå°¾
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h);
                        ctx.lineTo(x + w/2, y + h + 40 + 10*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                    } else if (level === 4) {
                        // æœºèº«+å¤§å…‰ç¿¼+æµé€Ÿç¯+é—ªç”µ
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#0f0');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 20);
                        ctx.lineTo(x - 28, y + h);
                        ctx.lineTo(x + w + 28, y + h);
                        ctx.closePath(); ctx.fill();
                        // å¤§å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.5+0.2*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#0f0';
                        ctx.lineWidth = 28;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.2);
                        ctx.lineTo(x - 80, y + h + 30*Math.sin(t));
                        ctx.moveTo(x + w/2, y + h*0.2);
                        ctx.lineTo(x + w + 80, y + h + 30*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                        // æµé€Ÿç¯
                        ctx.save();
                        ctx.globalAlpha = 0.3+0.2*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#0f0';
                        ctx.lineWidth = 10;
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*1.0 + 16*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                        ctx.stroke();
                        ctx.restore();
                        // é—ªç”µ
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        for(let i=0;i<2;i++){
                            let baseX = i===0 ? x-16 : x+w+16;
                            ctx.beginPath();
                            ctx.moveTo(x + w/2, y + h*0.5);
                            for(let j=0;j<5;j++){
                                let dx = baseX + (Math.random()-0.5)*12;
                                let dy = y + h*0.5 + (j+1)*(h*0.1);
                                ctx.lineTo(dx, dy);
                            }
                            ctx.stroke();
                        }
                        ctx.restore();
                    } else if (level === 5) {
                        // æœºèº«+è¶…å¤§å…‰ç¿¼+å¤šé‡æµé€Ÿç¯+ç²’å­çˆ†å‘+å…‰é€Ÿå°¾
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#0f0');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 32);
                        ctx.lineTo(x - 48, y + h);
                        ctx.lineTo(x + w + 48, y + h);
                        ctx.closePath(); ctx.fill();
                        // è¶…å¤§å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.4+0.3*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#0f0';
                        ctx.lineWidth = 48;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.1);
                        ctx.lineTo(x - 160, y + h + 80*Math.sin(t));
                        ctx.moveTo(x + w/2, y + h*0.1);
                        ctx.lineTo(x + w + 160, y + h + 80*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                        // å¤šé‡æµé€Ÿç¯
                        for(let k=0;k<3;k++){
                            ctx.save();
                            ctx.globalAlpha = 0.2+0.2*k;
                            ctx.strokeStyle = '#0f0';
                            ctx.lineWidth = 14-3*k;
                            ctx.beginPath();
                            ctx.arc(x + w/2, y + h*0.7, w*1.3 + 24*k*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                            ctx.stroke();
                            ctx.restore();
                        }
                        // ç²’å­çˆ†å‘
                        for(let i=0;i<20;i++){
                            let angle = Math.PI*2*i/20 + t;
                            let px = x + w/2 + Math.cos(angle)*(w*1.5+30*Math.abs(Math.sin(t)));
                            let py = y + h*0.7 + Math.sin(angle)*(w*1.5+30*Math.abs(Math.sin(t)));
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(px, py, 7+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        // å…‰é€Ÿå°¾
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#0f0';
                        ctx.lineWidth = 16;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h);
                        ctx.lineTo(x + w/2, y + h + 120 + 60*Math.abs(Math.sin(t)));
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            },
            power: {
                name: 'ç«åŠ›å‹', color: '#f66', speed: 3, bulletColor: '#f00',
                draw: function(ctx, x, y, w, h, level) {
                    let t = Date.now()/250;
                    if (level === 1) {
                        // çº¢è‰²åšé‡æœºèº«+é‡‘è‰²èƒ½é‡æ¡
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#f66'); grad.addColorStop(1, '#a00');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y-10);
                        ctx.lineTo(x-12, y + h);
                        ctx.lineTo(x + w+12, y + h);
                        ctx.closePath(); ctx.fill();
                        // èƒ½é‡æ¡
                        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4;
                        ctx.beginPath(); ctx.moveTo(x + w/2, y); ctx.lineTo(x + w/2, y + h); ctx.stroke();
                    } else if (level === 2) {
                        // æœºèº«+èƒ½é‡çˆ†å‘+åŒèƒ½é‡æ¡
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#f66'); grad.addColorStop(1, '#ffd700');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y-16);
                        ctx.lineTo(x-18, y + h);
                        ctx.lineTo(x + w+18, y + h);
                        ctx.closePath(); ctx.fill();
                        // åŒèƒ½é‡æ¡
                        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4;
                        ctx.beginPath(); ctx.moveTo(x + w/2 - 8, y); ctx.lineTo(x + w/2 - 8, y + h); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(x + w/2 + 8, y); ctx.lineTo(x + w/2 + 8, y + h); ctx.stroke();
                        // èƒ½é‡çˆ†å‘
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*0.5 + 10*Math.abs(Math.sin(Date.now()/300)), 0, 2*Math.PI);
                        ctx.fill();
                        ctx.restore();
                    } else if (level === 3) {
                        // æœºèº«+ç«ç„°ç¯+ç²’å­çˆ†å‘+æ—‹è½¬èƒ½é‡ç¯
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#f00');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y-20);
                        ctx.lineTo(x-24, y + h);
                        ctx.lineTo(x + w+24, y + h);
                        ctx.closePath(); ctx.fill();
                        // æ—‹è½¬èƒ½é‡ç¯
                        ctx.save();
                        ctx.strokeStyle = '#ffd700';
                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.6, w*0.9, t, t+Math.PI*1.5);
                        ctx.stroke();
                        ctx.restore();
                        // ç²’å­çˆ†å‘
                        for(let i=0;i<10;i++){
                            let angle = Math.PI*2*i/10 + t;
                            let px = x + w/2 + Math.cos(angle)*w*0.8;
                            let py = y + h*0.6 + Math.sin(angle)*w*0.8;
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(px, py, 4+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        // ç«ç„°ç¯
                        ctx.save();
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = '#f00';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*0.7 + 8*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                        ctx.stroke();
                        ctx.restore();
                    } else if (level === 4) {
                        // æœºèº«+å¤§å…‰ç¿¼+çˆ†ç‚¸ç¯+ç«ç„°çˆ†å‘
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#f00');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 28);
                        ctx.lineTo(x - 32, y + h);
                        ctx.lineTo(x + w + 32, y + h);
                        ctx.closePath(); ctx.fill();
                        // å¤§å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.5+0.2*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 32;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.2);
                        ctx.lineTo(x - 100, y + h + 40*Math.sin(t));
                        ctx.moveTo(x + w/2, y + h*0.2);
                        ctx.lineTo(x + w + 100, y + h + 40*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                        // çˆ†ç‚¸ç¯
                        ctx.save();
                        ctx.globalAlpha = 0.3+0.2*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 12;
                        ctx.beginPath();
                        ctx.arc(x + w/2, y + h*0.7, w*1.1 + 20*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                        ctx.stroke();
                        ctx.restore();
                        // ç«ç„°çˆ†å‘
                        for(let i=0;i<12;i++){
                            let angle = Math.PI*2*i/12 + t;
                            let px = x + w/2 + Math.cos(angle)*(w*1.2+18*Math.abs(Math.sin(t)));
                            let py = y + h*0.7 + Math.sin(angle)*(w*1.2+18*Math.abs(Math.sin(t)));
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(px, py, 8+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                    } else if (level === 5) {
                        // æœºèº«+è¶…å¤§å…‰ç¿¼+å¤šé‡çˆ†ç‚¸ç¯+ç²’å­çˆ†å‘+ç«ç„°å…‰æŸ
                        let grad = ctx.createLinearGradient(x, y, x + w, y + h);
                        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#f00');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y - 40);
                        ctx.lineTo(x - 60, y + h);
                        ctx.lineTo(x + w + 60, y + h);
                        ctx.closePath(); ctx.fill();
                        // è¶…å¤§å…‰ç¿¼
                        ctx.save();
                        ctx.globalAlpha = 0.4+0.3*Math.abs(Math.sin(t));
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 56;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h*0.1);
                        ctx.lineTo(x - 180, y + h + 100*Math.sin(t));
                        ctx.moveTo(x + w/2, y + h*0.1);
                        ctx.lineTo(x + w + 180, y + h + 100*Math.sin(t));
                        ctx.stroke();
                        ctx.restore();
                        // å¤šé‡çˆ†ç‚¸ç¯
                        for(let k=0;k<3;k++){
                            ctx.save();
                            ctx.globalAlpha = 0.2+0.2*k;
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 16-3*k;
                            ctx.beginPath();
                            ctx.arc(x + w/2, y + h*0.7, w*1.5 + 30*k*Math.abs(Math.sin(t)), 0, 2*Math.PI);
                            ctx.stroke();
                            ctx.restore();
                        }
                        // ç²’å­çˆ†å‘
                        for(let i=0;i<24;i++){
                            let angle = Math.PI*2*i/24 + t;
                            let px = x + w/2 + Math.cos(angle)*(w*1.8+40*Math.abs(Math.sin(t)));
                            let py = y + h*0.7 + Math.sin(angle)*(w*1.8+40*Math.abs(Math.sin(t)));
                            ctx.save();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(px, py, 10+2*Math.sin(t+i), 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        // ç«ç„°å…‰æŸ
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.strokeStyle = '#f00';
                        ctx.lineWidth = 20;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h);
                        ctx.lineTo(x + w/2, y + h + 160 + 80*Math.abs(Math.sin(t)));
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };

        // ç»˜åˆ¶é€‰æ‹©ç•Œé¢é£æœºï¼ˆlevel=1ï¼‰
        planeTypes.balance.draw(document.getElementById('planeBalance').getContext('2d'), 10, 10, 40, 60, 1);
        planeTypes.speed.draw(document.getElementById('planeSpeed').getContext('2d'), 10, 10, 40, 60, 1);
        planeTypes.power.draw(document.getElementById('planePower').getContext('2d'), 10, 10, 40, 60, 1);

        // =====================
        // ä¸»å¾ªç¯å®šä¹‰å’Œè°ƒç”¨æ”¾åœ¨æœ€å
        function loop() {
            update();
            draw();
            scoreDiv.textContent = 'åˆ†æ•°: ' + score;
            updateLifeBar();
            requestAnimationFrame(loop);
        }
        // é¡µé¢åŠ è½½æ—¶åªè°ƒç”¨ä¸€æ¬¡
        loop();

        // ä»»åŠ¡ä¸æˆå°±æ•°æ®å’Œç›¸å…³å˜é‡ï¼ˆæå‰å£°æ˜ï¼‰
        const tasks = [
            { id: 'kill10', desc: 'ç´¯è®¡å‡»æ¯10æ¶æ•Œæœº', type: 'kill', target: 10, done: false },
            { id: 'score1000', desc: 'å•å±€å¾—åˆ†è¾¾åˆ°1000', type: 'score', target: 1000, done: false },
            { id: 'pickup5', desc: 'ç´¯è®¡åƒåˆ°5ä¸ªé“å…·', type: 'pickup', target: 5, done: false }
        ];
        const achievements = [
            { id: 'firstBoss', desc: 'é¦–æ¬¡å‡»è´¥Boss', done: false },
            { id: 'score10000', desc: 'ç´¯è®¡å¾—åˆ†è¾¾åˆ°10000', done: false },
            { id: 'beetleKiller', desc: 'å•å±€åªæ¶ˆç­10ä¸ªç”²è™«', done: false, title: 'ç”²è™«æ€æ‰‹' },
            { id: 'stinkKiller', desc: 'å•å±€åªæ¶ˆç­10ä¸ªé‡è‡­', done: false, title: 'é‡è‡­æ€æ‰‹' },
            { id: 'zeldaKing', desc: 'å•å±€åªæ¶ˆç­10ä¸ªæ—å…‹é™ˆå­', done: false, title: 'å¡å°”è¾¾ä¹‹ç‹' },
            { id: 'noPorcupine', desc: 'å•å±€è‡³å°‘æ¶ˆç­100ä¸ªè±ªçŒª', done: false, title: 'ä¸åƒè±ªçŒª' }
        ];
        let taskProgress = { kill: 0, score: 0, pickup: 0 };
        let totalScore = 0;
       
        // ä»»åŠ¡é¢æ¿UIé€»è¾‘
        const taskBtn = document.getElementById('taskBtn');
        const taskPanel = document.getElementById('taskPanel');
        const closeTaskPanel = document.getElementById('closeTaskPanel');
        const taskList = document.getElementById('taskList');
        const achieveList = document.getElementById('achieveList');
// ä»»åŠ¡/æˆå°±æŒ‰é’®ç‚¹å‡»ï¼Œæ˜¾ç¤ºä»»åŠ¡é¢æ¿
taskBtn.onclick = function() {
    renderTaskPanel(); // æ¸²æŸ“å†…å®¹
    taskPanel.style.display = 'block'; // æ˜¾ç¤ºé¢æ¿
};
// å…³é—­æŒ‰é’®ç‚¹å‡»ï¼Œéšè—ä»»åŠ¡é¢æ¿
closeTaskPanel.onclick = function() {
    taskPanel.style.display = 'none';
};
// é™éŸ³æŒ‰é’®ç‚¹å‡»ï¼Œåˆ‡æ¢é™éŸ³çŠ¶æ€
muteBtn.onclick = function() {
    if (bgm.muted) {
        bgm.muted = false;
        muteBtn.textContent = 'ğŸ”Š';
    } else {
        bgm.muted = true;
        muteBtn.textContent = 'ğŸ”‡';
    }
};        

        function renderTaskPanel() {
            // ä»»åŠ¡
            taskList.innerHTML = '<b>ä»»åŠ¡</b><ul style="padding-left:18px;">' + tasks.map(t => `<li style='color:${t.done?'#0f0':'#fff'};'>${t.desc} ${t.done?'âœ…':''}</li>`).join('') + '</ul>';
            // æˆå°±
            achieveList.innerHTML = '<b>æˆå°±/ç§°å·</b><ul style="padding-left:18px;">' + achievements.map((a,idx) => {
                let btn = '';
                if(a.title && a.done) {
                    btn = `<button onclick="window.equipTitle('${a.title}')" style='margin-left:8px;padding:2px 10px;font-size:13px;border-radius:5px;background:${equippedTitle===a.title?'#ffd700':'#0ff'};color:#222;border:none;cursor:pointer;'>${equippedTitle===a.title?'å·²ä½©æˆ´':'ä½©æˆ´'}</button>`;
                }
                return `<li style='color:${a.done?'#ffd700':'#fff'};'>${a.desc}${a.title?` <span style='color:#0ff'>[${a.title}]</span>`:''} ${a.done?'ğŸ†':''} ${btn}</li>`;
            }).join('') + '</ul>';
        }
        // ä½©æˆ´ç§°å·å‡½æ•°
        window.equipTitle = function(title) {
            equippedTitle = title;
            renderTaskPanel();
        }
        // åˆ¤å®šç‰¹æ®Šæˆå°±å‡½æ•°
        function checkSpecialAchievements() {
            // ç”²è™«æ€æ‰‹ï¼šåªæ¶ˆç­10ä¸ªç”²è™«ï¼ˆenemy3ï¼‰ï¼Œå…¶ä»–ç±»å‹ä¸º0
            if(killCount[2]===10 && killCount[0]===0 && killCount[1]===0 && killCount[3]===0) {
                let a = achievements.find(a=>a.id==='beetleKiller');
                if(a && !a.done) { a.done=true; showAchieveToast(a.title); }
            }
            // é‡è‡­æ€æ‰‹ï¼šåªæ¶ˆç­10ä¸ªé‡è‡­ï¼ˆenemy4ï¼‰ï¼Œå…¶ä»–ç±»å‹ä¸º0
            if(killCount[3]===10 && killCount[0]===0 && killCount[1]===0 && killCount[2]===0) {
                let a = achievements.find(a=>a.id==='stinkKiller');
                if(a && !a.done) { a.done=true; showAchieveToast(a.title); }
            }
            // å¡å°”è¾¾ä¹‹ç‹ï¼šåªæ¶ˆç­10ä¸ªæ—å…‹é™ˆå­ï¼ˆenemy1ï¼‰ï¼Œå…¶ä»–ç±»å‹ä¸º0
            if(killCount[0]===10 && killCount[1]===0 && killCount[2]===0 && killCount[3]===0) {
                let a = achievements.find(a=>a.id==='zeldaKing');
                if(a && !a.done) { a.done=true; showAchieveToast(a.title); }
            }
            // ä¸åƒè±ªçŒªï¼šè‡³å°‘æ¶ˆç­100ä¸ªè±ªçŒªï¼ˆenemy2ï¼‰
            if(killCount[1]>=100) {
                let a = achievements.find(a=>a.id==='noPorcupine');
                if(a && !a.done) { a.done=true; showAchieveToast(a.title); }
            }
            renderTaskPanel();
        }
        // å¼¹å‡ºç§°å·è§£é”æç¤º
        function showAchieveToast(title) {
            let toast = document.createElement('div');
            toast.textContent = `è·å¾—ç§°å·ï¼š${title}`;
            toast.style.cssText = 'position:fixed;left:50%;top:30%;transform:translate(-50%,-50%);background:#222;color:#ffd700;font-size:22px;padding:18px 36px;border-radius:10px;z-index:200;box-shadow:0 0 24px #ffd700;text-align:center;';
            document.body.appendChild(toast);
            setTimeout(()=>{toast.remove();}, 2200);
        }
    </script>
</body>
</html>